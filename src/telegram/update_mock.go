package telegram

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i standup-bot/src/telegram.Update -o ./update_mock.go -n UpdateMock

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// UpdateMock implements Update
type UpdateMock struct {
	t minimock.Tester

	funcId          func() (i1 int)
	inspectFuncId   func()
	afterIdCounter  uint64
	beforeIdCounter uint64
	IdMock          mUpdateMockId

	funcMessage          func() (o1 OutgoingMessage)
	inspectFuncMessage   func()
	afterMessageCounter  uint64
	beforeMessageCounter uint64
	MessageMock          mUpdateMockMessage
}

// NewUpdateMock returns a mock for Update
func NewUpdateMock(t minimock.Tester) *UpdateMock {
	m := &UpdateMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.IdMock = mUpdateMockId{mock: m}

	m.MessageMock = mUpdateMockMessage{mock: m}

	return m
}

type mUpdateMockId struct {
	mock               *UpdateMock
	defaultExpectation *UpdateMockIdExpectation
	expectations       []*UpdateMockIdExpectation
}

// UpdateMockIdExpectation specifies expectation struct of the Update.Id
type UpdateMockIdExpectation struct {
	mock *UpdateMock

	results *UpdateMockIdResults
	Counter uint64
}

// UpdateMockIdResults contains results of the Update.Id
type UpdateMockIdResults struct {
	i1 int
}

// Expect sets up expected params for Update.Id
func (mmId *mUpdateMockId) Expect() *mUpdateMockId {
	if mmId.mock.funcId != nil {
		mmId.mock.t.Fatalf("UpdateMock.Id mock is already set by Set")
	}

	if mmId.defaultExpectation == nil {
		mmId.defaultExpectation = &UpdateMockIdExpectation{}
	}

	return mmId
}

// Inspect accepts an inspector function that has same arguments as the Update.Id
func (mmId *mUpdateMockId) Inspect(f func()) *mUpdateMockId {
	if mmId.mock.inspectFuncId != nil {
		mmId.mock.t.Fatalf("Inspect function is already set for UpdateMock.Id")
	}

	mmId.mock.inspectFuncId = f

	return mmId
}

// Return sets up results that will be returned by Update.Id
func (mmId *mUpdateMockId) Return(i1 int) *UpdateMock {
	if mmId.mock.funcId != nil {
		mmId.mock.t.Fatalf("UpdateMock.Id mock is already set by Set")
	}

	if mmId.defaultExpectation == nil {
		mmId.defaultExpectation = &UpdateMockIdExpectation{mock: mmId.mock}
	}
	mmId.defaultExpectation.results = &UpdateMockIdResults{i1}
	return mmId.mock
}

//Set uses given function f to mock the Update.Id method
func (mmId *mUpdateMockId) Set(f func() (i1 int)) *UpdateMock {
	if mmId.defaultExpectation != nil {
		mmId.mock.t.Fatalf("Default expectation is already set for the Update.Id method")
	}

	if len(mmId.expectations) > 0 {
		mmId.mock.t.Fatalf("Some expectations are already set for the Update.Id method")
	}

	mmId.mock.funcId = f
	return mmId.mock
}

// Id implements Update
func (mmId *UpdateMock) Id() (i1 int) {
	mm_atomic.AddUint64(&mmId.beforeIdCounter, 1)
	defer mm_atomic.AddUint64(&mmId.afterIdCounter, 1)

	if mmId.inspectFuncId != nil {
		mmId.inspectFuncId()
	}

	if mmId.IdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmId.IdMock.defaultExpectation.Counter, 1)

		mm_results := mmId.IdMock.defaultExpectation.results
		if mm_results == nil {
			mmId.t.Fatal("No results are set for the UpdateMock.Id")
		}
		return (*mm_results).i1
	}
	if mmId.funcId != nil {
		return mmId.funcId()
	}
	mmId.t.Fatalf("Unexpected call to UpdateMock.Id.")
	return
}

// IdAfterCounter returns a count of finished UpdateMock.Id invocations
func (mmId *UpdateMock) IdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmId.afterIdCounter)
}

// IdBeforeCounter returns a count of UpdateMock.Id invocations
func (mmId *UpdateMock) IdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmId.beforeIdCounter)
}

// MinimockIdDone returns true if the count of the Id invocations corresponds
// the number of defined expectations
func (m *UpdateMock) MinimockIdDone() bool {
	for _, e := range m.IdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcId != nil && mm_atomic.LoadUint64(&m.afterIdCounter) < 1 {
		return false
	}
	return true
}

// MinimockIdInspect logs each unmet expectation
func (m *UpdateMock) MinimockIdInspect() {
	for _, e := range m.IdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to UpdateMock.Id")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.IdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterIdCounter) < 1 {
		m.t.Error("Expected call to UpdateMock.Id")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcId != nil && mm_atomic.LoadUint64(&m.afterIdCounter) < 1 {
		m.t.Error("Expected call to UpdateMock.Id")
	}
}

type mUpdateMockMessage struct {
	mock               *UpdateMock
	defaultExpectation *UpdateMockMessageExpectation
	expectations       []*UpdateMockMessageExpectation
}

// UpdateMockMessageExpectation specifies expectation struct of the Update.Message
type UpdateMockMessageExpectation struct {
	mock *UpdateMock

	results *UpdateMockMessageResults
	Counter uint64
}

// UpdateMockMessageResults contains results of the Update.Message
type UpdateMockMessageResults struct {
	o1 OutgoingMessage
}

// Expect sets up expected params for Update.Message
func (mmMessage *mUpdateMockMessage) Expect() *mUpdateMockMessage {
	if mmMessage.mock.funcMessage != nil {
		mmMessage.mock.t.Fatalf("UpdateMock.Message mock is already set by Set")
	}

	if mmMessage.defaultExpectation == nil {
		mmMessage.defaultExpectation = &UpdateMockMessageExpectation{}
	}

	return mmMessage
}

// Inspect accepts an inspector function that has same arguments as the Update.Message
func (mmMessage *mUpdateMockMessage) Inspect(f func()) *mUpdateMockMessage {
	if mmMessage.mock.inspectFuncMessage != nil {
		mmMessage.mock.t.Fatalf("Inspect function is already set for UpdateMock.Message")
	}

	mmMessage.mock.inspectFuncMessage = f

	return mmMessage
}

// Return sets up results that will be returned by Update.Message
func (mmMessage *mUpdateMockMessage) Return(o1 OutgoingMessage) *UpdateMock {
	if mmMessage.mock.funcMessage != nil {
		mmMessage.mock.t.Fatalf("UpdateMock.Message mock is already set by Set")
	}

	if mmMessage.defaultExpectation == nil {
		mmMessage.defaultExpectation = &UpdateMockMessageExpectation{mock: mmMessage.mock}
	}
	mmMessage.defaultExpectation.results = &UpdateMockMessageResults{o1}
	return mmMessage.mock
}

//Set uses given function f to mock the Update.Message method
func (mmMessage *mUpdateMockMessage) Set(f func() (o1 OutgoingMessage)) *UpdateMock {
	if mmMessage.defaultExpectation != nil {
		mmMessage.mock.t.Fatalf("Default expectation is already set for the Update.Message method")
	}

	if len(mmMessage.expectations) > 0 {
		mmMessage.mock.t.Fatalf("Some expectations are already set for the Update.Message method")
	}

	mmMessage.mock.funcMessage = f
	return mmMessage.mock
}

// Message implements Update
func (mmMessage *UpdateMock) Message() (o1 OutgoingMessage) {
	mm_atomic.AddUint64(&mmMessage.beforeMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmMessage.afterMessageCounter, 1)

	if mmMessage.inspectFuncMessage != nil {
		mmMessage.inspectFuncMessage()
	}

	if mmMessage.MessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMessage.MessageMock.defaultExpectation.Counter, 1)

		mm_results := mmMessage.MessageMock.defaultExpectation.results
		if mm_results == nil {
			mmMessage.t.Fatal("No results are set for the UpdateMock.Message")
		}
		return (*mm_results).o1
	}
	if mmMessage.funcMessage != nil {
		return mmMessage.funcMessage()
	}
	mmMessage.t.Fatalf("Unexpected call to UpdateMock.Message.")
	return
}

// MessageAfterCounter returns a count of finished UpdateMock.Message invocations
func (mmMessage *UpdateMock) MessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMessage.afterMessageCounter)
}

// MessageBeforeCounter returns a count of UpdateMock.Message invocations
func (mmMessage *UpdateMock) MessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMessage.beforeMessageCounter)
}

// MinimockMessageDone returns true if the count of the Message invocations corresponds
// the number of defined expectations
func (m *UpdateMock) MinimockMessageDone() bool {
	for _, e := range m.MessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMessage != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockMessageInspect logs each unmet expectation
func (m *UpdateMock) MinimockMessageInspect() {
	for _, e := range m.MessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to UpdateMock.Message")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		m.t.Error("Expected call to UpdateMock.Message")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMessage != nil && mm_atomic.LoadUint64(&m.afterMessageCounter) < 1 {
		m.t.Error("Expected call to UpdateMock.Message")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *UpdateMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockIdInspect()

		m.MinimockMessageInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *UpdateMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *UpdateMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockIdDone() &&
		m.MinimockMessageDone()
}
