package telegram

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i standup-bot/src/telegram.IncomingMessage -o ./incoming_message_mock.go -n IncomingMessageMock

import (
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// IncomingMessageMock implements IncomingMessage
type IncomingMessageMock struct {
	t minimock.Tester

	funcChatId          func() (i1 int64)
	inspectFuncChatId   func()
	afterChatIdCounter  uint64
	beforeChatIdCounter uint64
	ChatIdMock          mIncomingMessageMockChatId

	funcText          func() (s1 string)
	inspectFuncText   func()
	afterTextCounter  uint64
	beforeTextCounter uint64
	TextMock          mIncomingMessageMockText

	funcUserId          func() (i1 int)
	inspectFuncUserId   func()
	afterUserIdCounter  uint64
	beforeUserIdCounter uint64
	UserIdMock          mIncomingMessageMockUserId
}

// NewIncomingMessageMock returns a mock for IncomingMessage
func NewIncomingMessageMock(t minimock.Tester) *IncomingMessageMock {
	m := &IncomingMessageMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ChatIdMock = mIncomingMessageMockChatId{mock: m}

	m.TextMock = mIncomingMessageMockText{mock: m}

	m.UserIdMock = mIncomingMessageMockUserId{mock: m}

	return m
}

type mIncomingMessageMockChatId struct {
	mock               *IncomingMessageMock
	defaultExpectation *IncomingMessageMockChatIdExpectation
	expectations       []*IncomingMessageMockChatIdExpectation
}

// IncomingMessageMockChatIdExpectation specifies expectation struct of the IncomingMessage.ChatId
type IncomingMessageMockChatIdExpectation struct {
	mock *IncomingMessageMock

	results *IncomingMessageMockChatIdResults
	Counter uint64
}

// IncomingMessageMockChatIdResults contains results of the IncomingMessage.ChatId
type IncomingMessageMockChatIdResults struct {
	i1 int64
}

// Expect sets up expected params for IncomingMessage.ChatId
func (mmChatId *mIncomingMessageMockChatId) Expect() *mIncomingMessageMockChatId {
	if mmChatId.mock.funcChatId != nil {
		mmChatId.mock.t.Fatalf("IncomingMessageMock.ChatId mock is already set by Set")
	}

	if mmChatId.defaultExpectation == nil {
		mmChatId.defaultExpectation = &IncomingMessageMockChatIdExpectation{}
	}

	return mmChatId
}

// Inspect accepts an inspector function that has same arguments as the IncomingMessage.ChatId
func (mmChatId *mIncomingMessageMockChatId) Inspect(f func()) *mIncomingMessageMockChatId {
	if mmChatId.mock.inspectFuncChatId != nil {
		mmChatId.mock.t.Fatalf("Inspect function is already set for IncomingMessageMock.ChatId")
	}

	mmChatId.mock.inspectFuncChatId = f

	return mmChatId
}

// Return sets up results that will be returned by IncomingMessage.ChatId
func (mmChatId *mIncomingMessageMockChatId) Return(i1 int64) *IncomingMessageMock {
	if mmChatId.mock.funcChatId != nil {
		mmChatId.mock.t.Fatalf("IncomingMessageMock.ChatId mock is already set by Set")
	}

	if mmChatId.defaultExpectation == nil {
		mmChatId.defaultExpectation = &IncomingMessageMockChatIdExpectation{mock: mmChatId.mock}
	}
	mmChatId.defaultExpectation.results = &IncomingMessageMockChatIdResults{i1}
	return mmChatId.mock
}

//Set uses given function f to mock the IncomingMessage.ChatId method
func (mmChatId *mIncomingMessageMockChatId) Set(f func() (i1 int64)) *IncomingMessageMock {
	if mmChatId.defaultExpectation != nil {
		mmChatId.mock.t.Fatalf("Default expectation is already set for the IncomingMessage.ChatId method")
	}

	if len(mmChatId.expectations) > 0 {
		mmChatId.mock.t.Fatalf("Some expectations are already set for the IncomingMessage.ChatId method")
	}

	mmChatId.mock.funcChatId = f
	return mmChatId.mock
}

// ChatId implements IncomingMessage
func (mmChatId *IncomingMessageMock) ChatId() (i1 int64) {
	mm_atomic.AddUint64(&mmChatId.beforeChatIdCounter, 1)
	defer mm_atomic.AddUint64(&mmChatId.afterChatIdCounter, 1)

	if mmChatId.inspectFuncChatId != nil {
		mmChatId.inspectFuncChatId()
	}

	if mmChatId.ChatIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmChatId.ChatIdMock.defaultExpectation.Counter, 1)

		mm_results := mmChatId.ChatIdMock.defaultExpectation.results
		if mm_results == nil {
			mmChatId.t.Fatal("No results are set for the IncomingMessageMock.ChatId")
		}
		return (*mm_results).i1
	}
	if mmChatId.funcChatId != nil {
		return mmChatId.funcChatId()
	}
	mmChatId.t.Fatalf("Unexpected call to IncomingMessageMock.ChatId.")
	return
}

// ChatIdAfterCounter returns a count of finished IncomingMessageMock.ChatId invocations
func (mmChatId *IncomingMessageMock) ChatIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChatId.afterChatIdCounter)
}

// ChatIdBeforeCounter returns a count of IncomingMessageMock.ChatId invocations
func (mmChatId *IncomingMessageMock) ChatIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmChatId.beforeChatIdCounter)
}

// MinimockChatIdDone returns true if the count of the ChatId invocations corresponds
// the number of defined expectations
func (m *IncomingMessageMock) MinimockChatIdDone() bool {
	for _, e := range m.ChatIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChatIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChatIdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChatId != nil && mm_atomic.LoadUint64(&m.afterChatIdCounter) < 1 {
		return false
	}
	return true
}

// MinimockChatIdInspect logs each unmet expectation
func (m *IncomingMessageMock) MinimockChatIdInspect() {
	for _, e := range m.ChatIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IncomingMessageMock.ChatId")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ChatIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterChatIdCounter) < 1 {
		m.t.Error("Expected call to IncomingMessageMock.ChatId")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcChatId != nil && mm_atomic.LoadUint64(&m.afterChatIdCounter) < 1 {
		m.t.Error("Expected call to IncomingMessageMock.ChatId")
	}
}

type mIncomingMessageMockText struct {
	mock               *IncomingMessageMock
	defaultExpectation *IncomingMessageMockTextExpectation
	expectations       []*IncomingMessageMockTextExpectation
}

// IncomingMessageMockTextExpectation specifies expectation struct of the IncomingMessage.Text
type IncomingMessageMockTextExpectation struct {
	mock *IncomingMessageMock

	results *IncomingMessageMockTextResults
	Counter uint64
}

// IncomingMessageMockTextResults contains results of the IncomingMessage.Text
type IncomingMessageMockTextResults struct {
	s1 string
}

// Expect sets up expected params for IncomingMessage.Text
func (mmText *mIncomingMessageMockText) Expect() *mIncomingMessageMockText {
	if mmText.mock.funcText != nil {
		mmText.mock.t.Fatalf("IncomingMessageMock.Text mock is already set by Set")
	}

	if mmText.defaultExpectation == nil {
		mmText.defaultExpectation = &IncomingMessageMockTextExpectation{}
	}

	return mmText
}

// Inspect accepts an inspector function that has same arguments as the IncomingMessage.Text
func (mmText *mIncomingMessageMockText) Inspect(f func()) *mIncomingMessageMockText {
	if mmText.mock.inspectFuncText != nil {
		mmText.mock.t.Fatalf("Inspect function is already set for IncomingMessageMock.Text")
	}

	mmText.mock.inspectFuncText = f

	return mmText
}

// Return sets up results that will be returned by IncomingMessage.Text
func (mmText *mIncomingMessageMockText) Return(s1 string) *IncomingMessageMock {
	if mmText.mock.funcText != nil {
		mmText.mock.t.Fatalf("IncomingMessageMock.Text mock is already set by Set")
	}

	if mmText.defaultExpectation == nil {
		mmText.defaultExpectation = &IncomingMessageMockTextExpectation{mock: mmText.mock}
	}
	mmText.defaultExpectation.results = &IncomingMessageMockTextResults{s1}
	return mmText.mock
}

//Set uses given function f to mock the IncomingMessage.Text method
func (mmText *mIncomingMessageMockText) Set(f func() (s1 string)) *IncomingMessageMock {
	if mmText.defaultExpectation != nil {
		mmText.mock.t.Fatalf("Default expectation is already set for the IncomingMessage.Text method")
	}

	if len(mmText.expectations) > 0 {
		mmText.mock.t.Fatalf("Some expectations are already set for the IncomingMessage.Text method")
	}

	mmText.mock.funcText = f
	return mmText.mock
}

// Text implements IncomingMessage
func (mmText *IncomingMessageMock) Text() (s1 string) {
	mm_atomic.AddUint64(&mmText.beforeTextCounter, 1)
	defer mm_atomic.AddUint64(&mmText.afterTextCounter, 1)

	if mmText.inspectFuncText != nil {
		mmText.inspectFuncText()
	}

	if mmText.TextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmText.TextMock.defaultExpectation.Counter, 1)

		mm_results := mmText.TextMock.defaultExpectation.results
		if mm_results == nil {
			mmText.t.Fatal("No results are set for the IncomingMessageMock.Text")
		}
		return (*mm_results).s1
	}
	if mmText.funcText != nil {
		return mmText.funcText()
	}
	mmText.t.Fatalf("Unexpected call to IncomingMessageMock.Text.")
	return
}

// TextAfterCounter returns a count of finished IncomingMessageMock.Text invocations
func (mmText *IncomingMessageMock) TextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmText.afterTextCounter)
}

// TextBeforeCounter returns a count of IncomingMessageMock.Text invocations
func (mmText *IncomingMessageMock) TextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmText.beforeTextCounter)
}

// MinimockTextDone returns true if the count of the Text invocations corresponds
// the number of defined expectations
func (m *IncomingMessageMock) MinimockTextDone() bool {
	for _, e := range m.TextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTextCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcText != nil && mm_atomic.LoadUint64(&m.afterTextCounter) < 1 {
		return false
	}
	return true
}

// MinimockTextInspect logs each unmet expectation
func (m *IncomingMessageMock) MinimockTextInspect() {
	for _, e := range m.TextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IncomingMessageMock.Text")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TextMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTextCounter) < 1 {
		m.t.Error("Expected call to IncomingMessageMock.Text")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcText != nil && mm_atomic.LoadUint64(&m.afterTextCounter) < 1 {
		m.t.Error("Expected call to IncomingMessageMock.Text")
	}
}

type mIncomingMessageMockUserId struct {
	mock               *IncomingMessageMock
	defaultExpectation *IncomingMessageMockUserIdExpectation
	expectations       []*IncomingMessageMockUserIdExpectation
}

// IncomingMessageMockUserIdExpectation specifies expectation struct of the IncomingMessage.UserId
type IncomingMessageMockUserIdExpectation struct {
	mock *IncomingMessageMock

	results *IncomingMessageMockUserIdResults
	Counter uint64
}

// IncomingMessageMockUserIdResults contains results of the IncomingMessage.UserId
type IncomingMessageMockUserIdResults struct {
	i1 int
}

// Expect sets up expected params for IncomingMessage.UserId
func (mmUserId *mIncomingMessageMockUserId) Expect() *mIncomingMessageMockUserId {
	if mmUserId.mock.funcUserId != nil {
		mmUserId.mock.t.Fatalf("IncomingMessageMock.UserId mock is already set by Set")
	}

	if mmUserId.defaultExpectation == nil {
		mmUserId.defaultExpectation = &IncomingMessageMockUserIdExpectation{}
	}

	return mmUserId
}

// Inspect accepts an inspector function that has same arguments as the IncomingMessage.UserId
func (mmUserId *mIncomingMessageMockUserId) Inspect(f func()) *mIncomingMessageMockUserId {
	if mmUserId.mock.inspectFuncUserId != nil {
		mmUserId.mock.t.Fatalf("Inspect function is already set for IncomingMessageMock.UserId")
	}

	mmUserId.mock.inspectFuncUserId = f

	return mmUserId
}

// Return sets up results that will be returned by IncomingMessage.UserId
func (mmUserId *mIncomingMessageMockUserId) Return(i1 int) *IncomingMessageMock {
	if mmUserId.mock.funcUserId != nil {
		mmUserId.mock.t.Fatalf("IncomingMessageMock.UserId mock is already set by Set")
	}

	if mmUserId.defaultExpectation == nil {
		mmUserId.defaultExpectation = &IncomingMessageMockUserIdExpectation{mock: mmUserId.mock}
	}
	mmUserId.defaultExpectation.results = &IncomingMessageMockUserIdResults{i1}
	return mmUserId.mock
}

//Set uses given function f to mock the IncomingMessage.UserId method
func (mmUserId *mIncomingMessageMockUserId) Set(f func() (i1 int)) *IncomingMessageMock {
	if mmUserId.defaultExpectation != nil {
		mmUserId.mock.t.Fatalf("Default expectation is already set for the IncomingMessage.UserId method")
	}

	if len(mmUserId.expectations) > 0 {
		mmUserId.mock.t.Fatalf("Some expectations are already set for the IncomingMessage.UserId method")
	}

	mmUserId.mock.funcUserId = f
	return mmUserId.mock
}

// UserId implements IncomingMessage
func (mmUserId *IncomingMessageMock) UserId() (i1 int) {
	mm_atomic.AddUint64(&mmUserId.beforeUserIdCounter, 1)
	defer mm_atomic.AddUint64(&mmUserId.afterUserIdCounter, 1)

	if mmUserId.inspectFuncUserId != nil {
		mmUserId.inspectFuncUserId()
	}

	if mmUserId.UserIdMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUserId.UserIdMock.defaultExpectation.Counter, 1)

		mm_results := mmUserId.UserIdMock.defaultExpectation.results
		if mm_results == nil {
			mmUserId.t.Fatal("No results are set for the IncomingMessageMock.UserId")
		}
		return (*mm_results).i1
	}
	if mmUserId.funcUserId != nil {
		return mmUserId.funcUserId()
	}
	mmUserId.t.Fatalf("Unexpected call to IncomingMessageMock.UserId.")
	return
}

// UserIdAfterCounter returns a count of finished IncomingMessageMock.UserId invocations
func (mmUserId *IncomingMessageMock) UserIdAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserId.afterUserIdCounter)
}

// UserIdBeforeCounter returns a count of IncomingMessageMock.UserId invocations
func (mmUserId *IncomingMessageMock) UserIdBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUserId.beforeUserIdCounter)
}

// MinimockUserIdDone returns true if the count of the UserId invocations corresponds
// the number of defined expectations
func (m *IncomingMessageMock) MinimockUserIdDone() bool {
	for _, e := range m.UserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UserIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUserIdCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserId != nil && mm_atomic.LoadUint64(&m.afterUserIdCounter) < 1 {
		return false
	}
	return true
}

// MinimockUserIdInspect logs each unmet expectation
func (m *IncomingMessageMock) MinimockUserIdInspect() {
	for _, e := range m.UserIdMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to IncomingMessageMock.UserId")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UserIdMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUserIdCounter) < 1 {
		m.t.Error("Expected call to IncomingMessageMock.UserId")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUserId != nil && mm_atomic.LoadUint64(&m.afterUserIdCounter) < 1 {
		m.t.Error("Expected call to IncomingMessageMock.UserId")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *IncomingMessageMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockChatIdInspect()

		m.MinimockTextInspect()

		m.MinimockUserIdInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *IncomingMessageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *IncomingMessageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockChatIdDone() &&
		m.MinimockTextDone() &&
		m.MinimockUserIdDone()
}
