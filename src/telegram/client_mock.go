package telegram

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i standup-bot/src/telegram.Client -o ./client_mock.go -n ClientMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ClientMock implements Client
type ClientMock struct {
	t minimock.Tester

	funcGetUpdates          func(offset int, timeout int, limit int) (ch1 chan Update)
	inspectFuncGetUpdates   func(offset int, timeout int, limit int)
	afterGetUpdatesCounter  uint64
	beforeGetUpdatesCounter uint64
	GetUpdatesMock          mClientMockGetUpdates

	funcSendMessage          func(o1 OutgoingMessage) (err error)
	inspectFuncSendMessage   func(o1 OutgoingMessage)
	afterSendMessageCounter  uint64
	beforeSendMessageCounter uint64
	SendMessageMock          mClientMockSendMessage
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetUpdatesMock = mClientMockGetUpdates{mock: m}
	m.GetUpdatesMock.callArgs = []*ClientMockGetUpdatesParams{}

	m.SendMessageMock = mClientMockSendMessage{mock: m}
	m.SendMessageMock.callArgs = []*ClientMockSendMessageParams{}

	return m
}

type mClientMockGetUpdates struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetUpdatesExpectation
	expectations       []*ClientMockGetUpdatesExpectation

	callArgs []*ClientMockGetUpdatesParams
	mutex    sync.RWMutex
}

// ClientMockGetUpdatesExpectation specifies expectation struct of the Client.GetUpdates
type ClientMockGetUpdatesExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetUpdatesParams
	results *ClientMockGetUpdatesResults
	Counter uint64
}

// ClientMockGetUpdatesParams contains parameters of the Client.GetUpdates
type ClientMockGetUpdatesParams struct {
	offset  int
	timeout int
	limit   int
}

// ClientMockGetUpdatesResults contains results of the Client.GetUpdates
type ClientMockGetUpdatesResults struct {
	ch1 chan Update
}

// Expect sets up expected params for Client.GetUpdates
func (mmGetUpdates *mClientMockGetUpdates) Expect(offset int, timeout int, limit int) *mClientMockGetUpdates {
	if mmGetUpdates.mock.funcGetUpdates != nil {
		mmGetUpdates.mock.t.Fatalf("ClientMock.GetUpdates mock is already set by Set")
	}

	if mmGetUpdates.defaultExpectation == nil {
		mmGetUpdates.defaultExpectation = &ClientMockGetUpdatesExpectation{}
	}

	mmGetUpdates.defaultExpectation.params = &ClientMockGetUpdatesParams{offset, timeout, limit}
	for _, e := range mmGetUpdates.expectations {
		if minimock.Equal(e.params, mmGetUpdates.defaultExpectation.params) {
			mmGetUpdates.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUpdates.defaultExpectation.params)
		}
	}

	return mmGetUpdates
}

// Inspect accepts an inspector function that has same arguments as the Client.GetUpdates
func (mmGetUpdates *mClientMockGetUpdates) Inspect(f func(offset int, timeout int, limit int)) *mClientMockGetUpdates {
	if mmGetUpdates.mock.inspectFuncGetUpdates != nil {
		mmGetUpdates.mock.t.Fatalf("Inspect function is already set for ClientMock.GetUpdates")
	}

	mmGetUpdates.mock.inspectFuncGetUpdates = f

	return mmGetUpdates
}

// Return sets up results that will be returned by Client.GetUpdates
func (mmGetUpdates *mClientMockGetUpdates) Return(ch1 chan Update) *ClientMock {
	if mmGetUpdates.mock.funcGetUpdates != nil {
		mmGetUpdates.mock.t.Fatalf("ClientMock.GetUpdates mock is already set by Set")
	}

	if mmGetUpdates.defaultExpectation == nil {
		mmGetUpdates.defaultExpectation = &ClientMockGetUpdatesExpectation{mock: mmGetUpdates.mock}
	}
	mmGetUpdates.defaultExpectation.results = &ClientMockGetUpdatesResults{ch1}
	return mmGetUpdates.mock
}

//Set uses given function f to mock the Client.GetUpdates method
func (mmGetUpdates *mClientMockGetUpdates) Set(f func(offset int, timeout int, limit int) (ch1 chan Update)) *ClientMock {
	if mmGetUpdates.defaultExpectation != nil {
		mmGetUpdates.mock.t.Fatalf("Default expectation is already set for the Client.GetUpdates method")
	}

	if len(mmGetUpdates.expectations) > 0 {
		mmGetUpdates.mock.t.Fatalf("Some expectations are already set for the Client.GetUpdates method")
	}

	mmGetUpdates.mock.funcGetUpdates = f
	return mmGetUpdates.mock
}

// When sets expectation for the Client.GetUpdates which will trigger the result defined by the following
// Then helper
func (mmGetUpdates *mClientMockGetUpdates) When(offset int, timeout int, limit int) *ClientMockGetUpdatesExpectation {
	if mmGetUpdates.mock.funcGetUpdates != nil {
		mmGetUpdates.mock.t.Fatalf("ClientMock.GetUpdates mock is already set by Set")
	}

	expectation := &ClientMockGetUpdatesExpectation{
		mock:   mmGetUpdates.mock,
		params: &ClientMockGetUpdatesParams{offset, timeout, limit},
	}
	mmGetUpdates.expectations = append(mmGetUpdates.expectations, expectation)
	return expectation
}

// Then sets up Client.GetUpdates return parameters for the expectation previously defined by the When method
func (e *ClientMockGetUpdatesExpectation) Then(ch1 chan Update) *ClientMock {
	e.results = &ClientMockGetUpdatesResults{ch1}
	return e.mock
}

// GetUpdates implements Client
func (mmGetUpdates *ClientMock) GetUpdates(offset int, timeout int, limit int) (ch1 chan Update) {
	mm_atomic.AddUint64(&mmGetUpdates.beforeGetUpdatesCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUpdates.afterGetUpdatesCounter, 1)

	if mmGetUpdates.inspectFuncGetUpdates != nil {
		mmGetUpdates.inspectFuncGetUpdates(offset, timeout, limit)
	}

	mm_params := &ClientMockGetUpdatesParams{offset, timeout, limit}

	// Record call args
	mmGetUpdates.GetUpdatesMock.mutex.Lock()
	mmGetUpdates.GetUpdatesMock.callArgs = append(mmGetUpdates.GetUpdatesMock.callArgs, mm_params)
	mmGetUpdates.GetUpdatesMock.mutex.Unlock()

	for _, e := range mmGetUpdates.GetUpdatesMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ch1
		}
	}

	if mmGetUpdates.GetUpdatesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUpdates.GetUpdatesMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUpdates.GetUpdatesMock.defaultExpectation.params
		mm_got := ClientMockGetUpdatesParams{offset, timeout, limit}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUpdates.t.Errorf("ClientMock.GetUpdates got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUpdates.GetUpdatesMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUpdates.t.Fatal("No results are set for the ClientMock.GetUpdates")
		}
		return (*mm_results).ch1
	}
	if mmGetUpdates.funcGetUpdates != nil {
		return mmGetUpdates.funcGetUpdates(offset, timeout, limit)
	}
	mmGetUpdates.t.Fatalf("Unexpected call to ClientMock.GetUpdates. %v %v %v", offset, timeout, limit)
	return
}

// GetUpdatesAfterCounter returns a count of finished ClientMock.GetUpdates invocations
func (mmGetUpdates *ClientMock) GetUpdatesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUpdates.afterGetUpdatesCounter)
}

// GetUpdatesBeforeCounter returns a count of ClientMock.GetUpdates invocations
func (mmGetUpdates *ClientMock) GetUpdatesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUpdates.beforeGetUpdatesCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.GetUpdates.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUpdates *mClientMockGetUpdates) Calls() []*ClientMockGetUpdatesParams {
	mmGetUpdates.mutex.RLock()

	argCopy := make([]*ClientMockGetUpdatesParams, len(mmGetUpdates.callArgs))
	copy(argCopy, mmGetUpdates.callArgs)

	mmGetUpdates.mutex.RUnlock()

	return argCopy
}

// MinimockGetUpdatesDone returns true if the count of the GetUpdates invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetUpdatesDone() bool {
	for _, e := range m.GetUpdatesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUpdatesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUpdatesCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUpdates != nil && mm_atomic.LoadUint64(&m.afterGetUpdatesCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetUpdatesInspect logs each unmet expectation
func (m *ClientMock) MinimockGetUpdatesInspect() {
	for _, e := range m.GetUpdatesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.GetUpdates with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetUpdatesMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetUpdatesCounter) < 1 {
		if m.GetUpdatesMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.GetUpdates")
		} else {
			m.t.Errorf("Expected call to ClientMock.GetUpdates with params: %#v", *m.GetUpdatesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUpdates != nil && mm_atomic.LoadUint64(&m.afterGetUpdatesCounter) < 1 {
		m.t.Error("Expected call to ClientMock.GetUpdates")
	}
}

type mClientMockSendMessage struct {
	mock               *ClientMock
	defaultExpectation *ClientMockSendMessageExpectation
	expectations       []*ClientMockSendMessageExpectation

	callArgs []*ClientMockSendMessageParams
	mutex    sync.RWMutex
}

// ClientMockSendMessageExpectation specifies expectation struct of the Client.SendMessage
type ClientMockSendMessageExpectation struct {
	mock    *ClientMock
	params  *ClientMockSendMessageParams
	results *ClientMockSendMessageResults
	Counter uint64
}

// ClientMockSendMessageParams contains parameters of the Client.SendMessage
type ClientMockSendMessageParams struct {
	o1 OutgoingMessage
}

// ClientMockSendMessageResults contains results of the Client.SendMessage
type ClientMockSendMessageResults struct {
	err error
}

// Expect sets up expected params for Client.SendMessage
func (mmSendMessage *mClientMockSendMessage) Expect(o1 OutgoingMessage) *mClientMockSendMessage {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ClientMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ClientMockSendMessageExpectation{}
	}

	mmSendMessage.defaultExpectation.params = &ClientMockSendMessageParams{o1}
	for _, e := range mmSendMessage.expectations {
		if minimock.Equal(e.params, mmSendMessage.defaultExpectation.params) {
			mmSendMessage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSendMessage.defaultExpectation.params)
		}
	}

	return mmSendMessage
}

// Inspect accepts an inspector function that has same arguments as the Client.SendMessage
func (mmSendMessage *mClientMockSendMessage) Inspect(f func(o1 OutgoingMessage)) *mClientMockSendMessage {
	if mmSendMessage.mock.inspectFuncSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("Inspect function is already set for ClientMock.SendMessage")
	}

	mmSendMessage.mock.inspectFuncSendMessage = f

	return mmSendMessage
}

// Return sets up results that will be returned by Client.SendMessage
func (mmSendMessage *mClientMockSendMessage) Return(err error) *ClientMock {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ClientMock.SendMessage mock is already set by Set")
	}

	if mmSendMessage.defaultExpectation == nil {
		mmSendMessage.defaultExpectation = &ClientMockSendMessageExpectation{mock: mmSendMessage.mock}
	}
	mmSendMessage.defaultExpectation.results = &ClientMockSendMessageResults{err}
	return mmSendMessage.mock
}

//Set uses given function f to mock the Client.SendMessage method
func (mmSendMessage *mClientMockSendMessage) Set(f func(o1 OutgoingMessage) (err error)) *ClientMock {
	if mmSendMessage.defaultExpectation != nil {
		mmSendMessage.mock.t.Fatalf("Default expectation is already set for the Client.SendMessage method")
	}

	if len(mmSendMessage.expectations) > 0 {
		mmSendMessage.mock.t.Fatalf("Some expectations are already set for the Client.SendMessage method")
	}

	mmSendMessage.mock.funcSendMessage = f
	return mmSendMessage.mock
}

// When sets expectation for the Client.SendMessage which will trigger the result defined by the following
// Then helper
func (mmSendMessage *mClientMockSendMessage) When(o1 OutgoingMessage) *ClientMockSendMessageExpectation {
	if mmSendMessage.mock.funcSendMessage != nil {
		mmSendMessage.mock.t.Fatalf("ClientMock.SendMessage mock is already set by Set")
	}

	expectation := &ClientMockSendMessageExpectation{
		mock:   mmSendMessage.mock,
		params: &ClientMockSendMessageParams{o1},
	}
	mmSendMessage.expectations = append(mmSendMessage.expectations, expectation)
	return expectation
}

// Then sets up Client.SendMessage return parameters for the expectation previously defined by the When method
func (e *ClientMockSendMessageExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockSendMessageResults{err}
	return e.mock
}

// SendMessage implements Client
func (mmSendMessage *ClientMock) SendMessage(o1 OutgoingMessage) (err error) {
	mm_atomic.AddUint64(&mmSendMessage.beforeSendMessageCounter, 1)
	defer mm_atomic.AddUint64(&mmSendMessage.afterSendMessageCounter, 1)

	if mmSendMessage.inspectFuncSendMessage != nil {
		mmSendMessage.inspectFuncSendMessage(o1)
	}

	mm_params := &ClientMockSendMessageParams{o1}

	// Record call args
	mmSendMessage.SendMessageMock.mutex.Lock()
	mmSendMessage.SendMessageMock.callArgs = append(mmSendMessage.SendMessageMock.callArgs, mm_params)
	mmSendMessage.SendMessageMock.mutex.Unlock()

	for _, e := range mmSendMessage.SendMessageMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSendMessage.SendMessageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSendMessage.SendMessageMock.defaultExpectation.Counter, 1)
		mm_want := mmSendMessage.SendMessageMock.defaultExpectation.params
		mm_got := ClientMockSendMessageParams{o1}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSendMessage.t.Errorf("ClientMock.SendMessage got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSendMessage.SendMessageMock.defaultExpectation.results
		if mm_results == nil {
			mmSendMessage.t.Fatal("No results are set for the ClientMock.SendMessage")
		}
		return (*mm_results).err
	}
	if mmSendMessage.funcSendMessage != nil {
		return mmSendMessage.funcSendMessage(o1)
	}
	mmSendMessage.t.Fatalf("Unexpected call to ClientMock.SendMessage. %v", o1)
	return
}

// SendMessageAfterCounter returns a count of finished ClientMock.SendMessage invocations
func (mmSendMessage *ClientMock) SendMessageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.afterSendMessageCounter)
}

// SendMessageBeforeCounter returns a count of ClientMock.SendMessage invocations
func (mmSendMessage *ClientMock) SendMessageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSendMessage.beforeSendMessageCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.SendMessage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSendMessage *mClientMockSendMessage) Calls() []*ClientMockSendMessageParams {
	mmSendMessage.mutex.RLock()

	argCopy := make([]*ClientMockSendMessageParams, len(mmSendMessage.callArgs))
	copy(argCopy, mmSendMessage.callArgs)

	mmSendMessage.mutex.RUnlock()

	return argCopy
}

// MinimockSendMessageDone returns true if the count of the SendMessage invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockSendMessageDone() bool {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		return false
	}
	return true
}

// MinimockSendMessageInspect logs each unmet expectation
func (m *ClientMock) MinimockSendMessageInspect() {
	for _, e := range m.SendMessageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.SendMessage with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SendMessageMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		if m.SendMessageMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.SendMessage")
		} else {
			m.t.Errorf("Expected call to ClientMock.SendMessage with params: %#v", *m.SendMessageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSendMessage != nil && mm_atomic.LoadUint64(&m.afterSendMessageCounter) < 1 {
		m.t.Error("Expected call to ClientMock.SendMessage")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockGetUpdatesInspect()

		m.MinimockSendMessageInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetUpdatesDone() &&
		m.MinimockSendMessageDone()
}
