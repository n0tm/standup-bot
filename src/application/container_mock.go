package application

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i standup-bot/src/application.Container -o ./container_mock.go -n ContainerMock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ContainerMock implements Container
type ContainerMock struct {
	t minimock.Tester

	funcInvoke          func(function interface{}) (err error)
	inspectFuncInvoke   func(function interface{})
	afterInvokeCounter  uint64
	beforeInvokeCounter uint64
	InvokeMock          mContainerMockInvoke

	funcProvide          func(constructor interface{}) (err error)
	inspectFuncProvide   func(constructor interface{})
	afterProvideCounter  uint64
	beforeProvideCounter uint64
	ProvideMock          mContainerMockProvide
}

// NewContainerMock returns a mock for Container
func NewContainerMock(t minimock.Tester) *ContainerMock {
	m := &ContainerMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.InvokeMock = mContainerMockInvoke{mock: m}
	m.InvokeMock.callArgs = []*ContainerMockInvokeParams{}

	m.ProvideMock = mContainerMockProvide{mock: m}
	m.ProvideMock.callArgs = []*ContainerMockProvideParams{}

	return m
}

type mContainerMockInvoke struct {
	mock               *ContainerMock
	defaultExpectation *ContainerMockInvokeExpectation
	expectations       []*ContainerMockInvokeExpectation

	callArgs []*ContainerMockInvokeParams
	mutex    sync.RWMutex
}

// ContainerMockInvokeExpectation specifies expectation struct of the Container.Invoke
type ContainerMockInvokeExpectation struct {
	mock    *ContainerMock
	params  *ContainerMockInvokeParams
	results *ContainerMockInvokeResults
	Counter uint64
}

// ContainerMockInvokeParams contains parameters of the Container.Invoke
type ContainerMockInvokeParams struct {
	function interface{}
}

// ContainerMockInvokeResults contains results of the Container.Invoke
type ContainerMockInvokeResults struct {
	err error
}

// Expect sets up expected params for Container.Invoke
func (mmInvoke *mContainerMockInvoke) Expect(function interface{}) *mContainerMockInvoke {
	if mmInvoke.mock.funcInvoke != nil {
		mmInvoke.mock.t.Fatalf("ContainerMock.Invoke mock is already set by Set")
	}

	if mmInvoke.defaultExpectation == nil {
		mmInvoke.defaultExpectation = &ContainerMockInvokeExpectation{}
	}

	mmInvoke.defaultExpectation.params = &ContainerMockInvokeParams{function}
	for _, e := range mmInvoke.expectations {
		if minimock.Equal(e.params, mmInvoke.defaultExpectation.params) {
			mmInvoke.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmInvoke.defaultExpectation.params)
		}
	}

	return mmInvoke
}

// Inspect accepts an inspector function that has same arguments as the Container.Invoke
func (mmInvoke *mContainerMockInvoke) Inspect(f func(function interface{})) *mContainerMockInvoke {
	if mmInvoke.mock.inspectFuncInvoke != nil {
		mmInvoke.mock.t.Fatalf("Inspect function is already set for ContainerMock.Invoke")
	}

	mmInvoke.mock.inspectFuncInvoke = f

	return mmInvoke
}

// Return sets up results that will be returned by Container.Invoke
func (mmInvoke *mContainerMockInvoke) Return(err error) *ContainerMock {
	if mmInvoke.mock.funcInvoke != nil {
		mmInvoke.mock.t.Fatalf("ContainerMock.Invoke mock is already set by Set")
	}

	if mmInvoke.defaultExpectation == nil {
		mmInvoke.defaultExpectation = &ContainerMockInvokeExpectation{mock: mmInvoke.mock}
	}
	mmInvoke.defaultExpectation.results = &ContainerMockInvokeResults{err}
	return mmInvoke.mock
}

//Set uses given function f to mock the Container.Invoke method
func (mmInvoke *mContainerMockInvoke) Set(f func(function interface{}) (err error)) *ContainerMock {
	if mmInvoke.defaultExpectation != nil {
		mmInvoke.mock.t.Fatalf("Default expectation is already set for the Container.Invoke method")
	}

	if len(mmInvoke.expectations) > 0 {
		mmInvoke.mock.t.Fatalf("Some expectations are already set for the Container.Invoke method")
	}

	mmInvoke.mock.funcInvoke = f
	return mmInvoke.mock
}

// When sets expectation for the Container.Invoke which will trigger the result defined by the following
// Then helper
func (mmInvoke *mContainerMockInvoke) When(function interface{}) *ContainerMockInvokeExpectation {
	if mmInvoke.mock.funcInvoke != nil {
		mmInvoke.mock.t.Fatalf("ContainerMock.Invoke mock is already set by Set")
	}

	expectation := &ContainerMockInvokeExpectation{
		mock:   mmInvoke.mock,
		params: &ContainerMockInvokeParams{function},
	}
	mmInvoke.expectations = append(mmInvoke.expectations, expectation)
	return expectation
}

// Then sets up Container.Invoke return parameters for the expectation previously defined by the When method
func (e *ContainerMockInvokeExpectation) Then(err error) *ContainerMock {
	e.results = &ContainerMockInvokeResults{err}
	return e.mock
}

// Invoke implements Container
func (mmInvoke *ContainerMock) Invoke(function interface{}) (err error) {
	mm_atomic.AddUint64(&mmInvoke.beforeInvokeCounter, 1)
	defer mm_atomic.AddUint64(&mmInvoke.afterInvokeCounter, 1)

	if mmInvoke.inspectFuncInvoke != nil {
		mmInvoke.inspectFuncInvoke(function)
	}

	mm_params := &ContainerMockInvokeParams{function}

	// Record call args
	mmInvoke.InvokeMock.mutex.Lock()
	mmInvoke.InvokeMock.callArgs = append(mmInvoke.InvokeMock.callArgs, mm_params)
	mmInvoke.InvokeMock.mutex.Unlock()

	for _, e := range mmInvoke.InvokeMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmInvoke.InvokeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmInvoke.InvokeMock.defaultExpectation.Counter, 1)
		mm_want := mmInvoke.InvokeMock.defaultExpectation.params
		mm_got := ContainerMockInvokeParams{function}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmInvoke.t.Errorf("ContainerMock.Invoke got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmInvoke.InvokeMock.defaultExpectation.results
		if mm_results == nil {
			mmInvoke.t.Fatal("No results are set for the ContainerMock.Invoke")
		}
		return (*mm_results).err
	}
	if mmInvoke.funcInvoke != nil {
		return mmInvoke.funcInvoke(function)
	}
	mmInvoke.t.Fatalf("Unexpected call to ContainerMock.Invoke. %v", function)
	return
}

// InvokeAfterCounter returns a count of finished ContainerMock.Invoke invocations
func (mmInvoke *ContainerMock) InvokeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInvoke.afterInvokeCounter)
}

// InvokeBeforeCounter returns a count of ContainerMock.Invoke invocations
func (mmInvoke *ContainerMock) InvokeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmInvoke.beforeInvokeCounter)
}

// Calls returns a list of arguments used in each call to ContainerMock.Invoke.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmInvoke *mContainerMockInvoke) Calls() []*ContainerMockInvokeParams {
	mmInvoke.mutex.RLock()

	argCopy := make([]*ContainerMockInvokeParams, len(mmInvoke.callArgs))
	copy(argCopy, mmInvoke.callArgs)

	mmInvoke.mutex.RUnlock()

	return argCopy
}

// MinimockInvokeDone returns true if the count of the Invoke invocations corresponds
// the number of defined expectations
func (m *ContainerMock) MinimockInvokeDone() bool {
	for _, e := range m.InvokeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InvokeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInvokeCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInvoke != nil && mm_atomic.LoadUint64(&m.afterInvokeCounter) < 1 {
		return false
	}
	return true
}

// MinimockInvokeInspect logs each unmet expectation
func (m *ContainerMock) MinimockInvokeInspect() {
	for _, e := range m.InvokeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContainerMock.Invoke with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.InvokeMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterInvokeCounter) < 1 {
		if m.InvokeMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContainerMock.Invoke")
		} else {
			m.t.Errorf("Expected call to ContainerMock.Invoke with params: %#v", *m.InvokeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcInvoke != nil && mm_atomic.LoadUint64(&m.afterInvokeCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.Invoke")
	}
}

type mContainerMockProvide struct {
	mock               *ContainerMock
	defaultExpectation *ContainerMockProvideExpectation
	expectations       []*ContainerMockProvideExpectation

	callArgs []*ContainerMockProvideParams
	mutex    sync.RWMutex
}

// ContainerMockProvideExpectation specifies expectation struct of the Container.Provide
type ContainerMockProvideExpectation struct {
	mock    *ContainerMock
	params  *ContainerMockProvideParams
	results *ContainerMockProvideResults
	Counter uint64
}

// ContainerMockProvideParams contains parameters of the Container.Provide
type ContainerMockProvideParams struct {
	constructor interface{}
}

// ContainerMockProvideResults contains results of the Container.Provide
type ContainerMockProvideResults struct {
	err error
}

// Expect sets up expected params for Container.Provide
func (mmProvide *mContainerMockProvide) Expect(constructor interface{}) *mContainerMockProvide {
	if mmProvide.mock.funcProvide != nil {
		mmProvide.mock.t.Fatalf("ContainerMock.Provide mock is already set by Set")
	}

	if mmProvide.defaultExpectation == nil {
		mmProvide.defaultExpectation = &ContainerMockProvideExpectation{}
	}

	mmProvide.defaultExpectation.params = &ContainerMockProvideParams{constructor}
	for _, e := range mmProvide.expectations {
		if minimock.Equal(e.params, mmProvide.defaultExpectation.params) {
			mmProvide.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmProvide.defaultExpectation.params)
		}
	}

	return mmProvide
}

// Inspect accepts an inspector function that has same arguments as the Container.Provide
func (mmProvide *mContainerMockProvide) Inspect(f func(constructor interface{})) *mContainerMockProvide {
	if mmProvide.mock.inspectFuncProvide != nil {
		mmProvide.mock.t.Fatalf("Inspect function is already set for ContainerMock.Provide")
	}

	mmProvide.mock.inspectFuncProvide = f

	return mmProvide
}

// Return sets up results that will be returned by Container.Provide
func (mmProvide *mContainerMockProvide) Return(err error) *ContainerMock {
	if mmProvide.mock.funcProvide != nil {
		mmProvide.mock.t.Fatalf("ContainerMock.Provide mock is already set by Set")
	}

	if mmProvide.defaultExpectation == nil {
		mmProvide.defaultExpectation = &ContainerMockProvideExpectation{mock: mmProvide.mock}
	}
	mmProvide.defaultExpectation.results = &ContainerMockProvideResults{err}
	return mmProvide.mock
}

//Set uses given function f to mock the Container.Provide method
func (mmProvide *mContainerMockProvide) Set(f func(constructor interface{}) (err error)) *ContainerMock {
	if mmProvide.defaultExpectation != nil {
		mmProvide.mock.t.Fatalf("Default expectation is already set for the Container.Provide method")
	}

	if len(mmProvide.expectations) > 0 {
		mmProvide.mock.t.Fatalf("Some expectations are already set for the Container.Provide method")
	}

	mmProvide.mock.funcProvide = f
	return mmProvide.mock
}

// When sets expectation for the Container.Provide which will trigger the result defined by the following
// Then helper
func (mmProvide *mContainerMockProvide) When(constructor interface{}) *ContainerMockProvideExpectation {
	if mmProvide.mock.funcProvide != nil {
		mmProvide.mock.t.Fatalf("ContainerMock.Provide mock is already set by Set")
	}

	expectation := &ContainerMockProvideExpectation{
		mock:   mmProvide.mock,
		params: &ContainerMockProvideParams{constructor},
	}
	mmProvide.expectations = append(mmProvide.expectations, expectation)
	return expectation
}

// Then sets up Container.Provide return parameters for the expectation previously defined by the When method
func (e *ContainerMockProvideExpectation) Then(err error) *ContainerMock {
	e.results = &ContainerMockProvideResults{err}
	return e.mock
}

// Provide implements Container
func (mmProvide *ContainerMock) Provide(constructor interface{}) (err error) {
	mm_atomic.AddUint64(&mmProvide.beforeProvideCounter, 1)
	defer mm_atomic.AddUint64(&mmProvide.afterProvideCounter, 1)

	if mmProvide.inspectFuncProvide != nil {
		mmProvide.inspectFuncProvide(constructor)
	}

	mm_params := &ContainerMockProvideParams{constructor}

	// Record call args
	mmProvide.ProvideMock.mutex.Lock()
	mmProvide.ProvideMock.callArgs = append(mmProvide.ProvideMock.callArgs, mm_params)
	mmProvide.ProvideMock.mutex.Unlock()

	for _, e := range mmProvide.ProvideMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmProvide.ProvideMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmProvide.ProvideMock.defaultExpectation.Counter, 1)
		mm_want := mmProvide.ProvideMock.defaultExpectation.params
		mm_got := ContainerMockProvideParams{constructor}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmProvide.t.Errorf("ContainerMock.Provide got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmProvide.ProvideMock.defaultExpectation.results
		if mm_results == nil {
			mmProvide.t.Fatal("No results are set for the ContainerMock.Provide")
		}
		return (*mm_results).err
	}
	if mmProvide.funcProvide != nil {
		return mmProvide.funcProvide(constructor)
	}
	mmProvide.t.Fatalf("Unexpected call to ContainerMock.Provide. %v", constructor)
	return
}

// ProvideAfterCounter returns a count of finished ContainerMock.Provide invocations
func (mmProvide *ContainerMock) ProvideAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProvide.afterProvideCounter)
}

// ProvideBeforeCounter returns a count of ContainerMock.Provide invocations
func (mmProvide *ContainerMock) ProvideBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmProvide.beforeProvideCounter)
}

// Calls returns a list of arguments used in each call to ContainerMock.Provide.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmProvide *mContainerMockProvide) Calls() []*ContainerMockProvideParams {
	mmProvide.mutex.RLock()

	argCopy := make([]*ContainerMockProvideParams, len(mmProvide.callArgs))
	copy(argCopy, mmProvide.callArgs)

	mmProvide.mutex.RUnlock()

	return argCopy
}

// MinimockProvideDone returns true if the count of the Provide invocations corresponds
// the number of defined expectations
func (m *ContainerMock) MinimockProvideDone() bool {
	for _, e := range m.ProvideMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProvideMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProvideCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProvide != nil && mm_atomic.LoadUint64(&m.afterProvideCounter) < 1 {
		return false
	}
	return true
}

// MinimockProvideInspect logs each unmet expectation
func (m *ContainerMock) MinimockProvideInspect() {
	for _, e := range m.ProvideMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ContainerMock.Provide with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ProvideMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterProvideCounter) < 1 {
		if m.ProvideMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ContainerMock.Provide")
		} else {
			m.t.Errorf("Expected call to ContainerMock.Provide with params: %#v", *m.ProvideMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcProvide != nil && mm_atomic.LoadUint64(&m.afterProvideCounter) < 1 {
		m.t.Error("Expected call to ContainerMock.Provide")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ContainerMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockInvokeInspect()

		m.MinimockProvideInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ContainerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ContainerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockInvokeDone() &&
		m.MinimockProvideDone()
}
